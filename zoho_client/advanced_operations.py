"""
Zoho CRM Advanced Operations
Implementation of Clone, Timeline, Count, Delink, and Mass Update operations
Generated by Subagent-5: Enhanced Record Operations Implementation

Based on:
- Clone Record API: https://www.zoho.com/crm/developer/docs/api/v8/clone-records.html
- Timeline API: https://www.zoho.com/crm/developer/docs/api/v8/timeline.html
- Record Count API: https://www.zoho.com/crm/developer/docs/api/v8/get-records-count.html
- Delink Records API: https://www.zoho.com/crm/developer/docs/api/v8/delink-records.html
"""

import logging
from typing import Optional, Dict, Any, List
from .base_client import ZohoBaseClient

logger = logging.getLogger(__name__)


class ZohoAdvancedOperations:
    """Handle advanced record operations in Zoho CRM"""

    def __init__(self):
        self.client = ZohoBaseClient()

    async def clone_record(
        self,
        module: str,
        record_id: str,
        modifications: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Clone an existing record, optionally modifying fields during the clone.

        API Reference: https://www.zoho.com/crm/developer/docs/api/v8/clone-records.html
        OAuth Scopes: ZohoCRM.modules.ALL or ZohoCRM.modules.{module_name}.CREATE

        Features:
        - Duplicates existing record with all field values from parent
        - Can modify field values during cloning
        - Excludes file/image uploads and read-only fields
        - Subform records can be cloned with parent record

        Args:
            module: Module API name (Leads, Contacts, Deals, etc.)
            record_id: ID of record to clone
            modifications: Optional dict of field modifications to apply during cloning

        Returns:
            Clone result with new record ID

        Example:
            # Clone a lead and change the last name
            result = await clone_record(
                "Leads",
                "4876876000000327001",
                modifications={"Last_Name": "Smith (Copy)"}
            )
        """
        endpoint = f"/{module}/{record_id}/actions/clone"

        # Build request body
        data = {}
        if modifications:
            data["data"] = [modifications]

        try:
            result = await self.client.post(endpoint, data=data)
            logger.info(f"Cloned record {record_id} in {module}")
            return result

        except Exception as e:
            logger.error(f"Error cloning record: {e}")
            raise

    async def get_record_timeline(
        self,
        module: str,
        record_id: str,
        per_page: int = 50,
        page_token: Optional[str] = None,
        include_signals: bool = False
    ) -> Dict[str, Any]:
        """
        Get the complete change history timeline for a record.

        API Reference: https://www.zoho.com/crm/developer/docs/api/v8/timeline.html
        OAuth Scopes: ZohoCRM.modules.{module_name}.ALL or ZohoCRM.modules.{module_name}.READ

        Features:
        - Shows who made changes, when, and what fields were modified
        - Source tracking: UI, API, workflow, mass_update, migration, etc.
        - Supports pagination for large timelines
        - Optional signal data (system-level events)

        Args:
            module: Module API name
            record_id: Record ID to get timeline for
            per_page: Number of timeline entries per page (max 50)
            page_token: Token for pagination (get from previous response)
            include_signals: Include system signals data

        Returns:
            Timeline data with changes, timestamps, and user info

        Example:
            # Get timeline for a deal
            timeline = await get_record_timeline("Deals", "4876876000000327001")

            # Paginate through more entries
            next_timeline = await get_record_timeline(
                "Deals",
                "4876876000000327001",
                page_token=timeline["info"]["page_token"]
            )
        """
        endpoint = f"/{module}/{record_id}/__timeline"

        # Build query parameters
        params = {"per_page": min(per_page, 50)}

        if page_token:
            params["page_token"] = page_token

        if include_signals:
            params["include_timeline_type"] = "signals"

        try:
            result = await self.client.get(endpoint, params=params)
            logger.info(f"Retrieved timeline for record {record_id} in {module}")
            return result

        except Exception as e:
            logger.error(f"Error getting record timeline: {e}")
            raise

    async def get_record_count(
        self,
        module: str,
        criteria: Optional[str] = None,
        cvid: Optional[str] = None,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        word: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Count records in a module with optional filtering.

        API Reference: https://www.zoho.com/crm/developer/docs/api/v8/get-records-count.html
        OAuth Scopes: ZohoSearch.securesearch.READ, ZohoCRM.modules.{module_name}.READ

        Features:
        - Count records with complex criteria
        - Search by email, phone, or word
        - Use custom views for filtering
        - 1-10 minute delay in statistics refresh

        Args:
            module: Module API name
            criteria: Filter criteria string (e.g., "(Status:equals:Qualified)")
            cvid: Custom View ID for filtering
            email: Count records with specific email
            phone: Count records with specific phone number
            word: Count records containing specific word

        Returns:
            Dict with count value

        Important Notes:
        - Cannot combine multiple search parameters
        - Statistics may be delayed 1-10 minutes
        - Only one search parameter allowed at a time

        Example:
            # Count all qualified leads
            count = await get_record_count("Leads", criteria="(Status:equals:Qualified)")
            # Returns: {"count": 42}

            # Count records with specific email
            count = await get_record_count("Contacts", email="john@example.com")
        """
        endpoint = f"/{module}/actions/count"

        # Build query parameters
        params = {}

        if criteria:
            params["criteria"] = criteria
        if cvid:
            params["cvid"] = cvid
        if email:
            params["email"] = email
        if phone:
            params["phone"] = phone
        if word:
            params["word"] = word

        # Validate only one search parameter
        search_params = sum([bool(email), bool(phone), bool(word)])
        if search_params > 1:
            raise ValueError("Cannot combine email, phone, and word search parameters")

        try:
            result = await self.client.get(endpoint, params=params)
            logger.info(f"Retrieved count for {module}: {result.get('count', 0)}")
            return result

        except Exception as e:
            logger.error(f"Error getting record count: {e}")
            raise

    async def delink_related_records(
        self,
        module: str,
        record_id: str,
        related_list: str,
        related_ids: List[str]
    ) -> Dict[str, Any]:
        """
        Remove relationships between records (delink related records).

        API Reference: https://www.zoho.com/crm/developer/docs/api/v8/delink-records.html
        OAuth Scopes: ZohoCRM.modules.ALL or ZohoCRM.modules.{module_name}.UPDATE

        Supported Relations:
        - Campaigns â†’ Leads, Contacts
        - Products â†’ Leads, Accounts, Contacts, Potentials, Price Books
        - Appointments â†’ Services

        Features:
        - Remove up to 100 relationships per call
        - Preserves the records, only removes the link
        - Does not delete any records

        Args:
            module: Module API name (Campaigns, Products, Appointments)
            record_id: ID of the parent record
            related_list: Related list API name (Leads, Contacts, Products, etc.)
            related_ids: List of related record IDs to delink (max 100)

        Returns:
            Success confirmation with details

        Example:
            # Remove leads from a campaign
            result = await delink_related_records(
                "Campaigns",
                "4876876000000327001",
                "Leads",
                ["4876876000000327002", "4876876000000327003"]
            )

            # Remove products from a contact
            result = await delink_related_records(
                "Contacts",
                "4876876000000123456",
                "Products",
                ["4876876000000789012"]
            )
        """
        if len(related_ids) > 100:
            raise ValueError("Maximum 100 related records can be delinked per call")

        endpoint = f"/{module}/{record_id}/{related_list}"

        # Convert IDs to comma-separated string
        params = {"ids": ",".join(related_ids)}

        try:
            result = await self.client.delete(endpoint, params=params)
            logger.info(f"Delinked {len(related_ids)} {related_list} from {module} record {record_id}")
            return result

        except Exception as e:
            logger.error(f"Error delinking related records: {e}")
            raise

    async def mass_update_records(
        self,
        module: str,
        record_ids: List[str],
        field_updates: Dict[str, Any],
        trigger_workflow: bool = False
    ) -> Dict[str, Any]:
        """
        Update the same field(s) across multiple records in a single operation.

        This is a convenience method that uses the bulk_update API to update
        multiple records with the same field values.

        Features:
        - Update up to 100 records per call
        - Apply same field changes to all records
        - Optional workflow triggers
        - More efficient than individual updates

        Args:
            module: Module API name
            record_ids: List of record IDs to update (max 100)
            field_updates: Dict of fields to update with their new values
            trigger_workflow: Whether to trigger workflow rules

        Returns:
            Update summary with success/failure counts

        Example:
            # Update status for multiple leads
            result = await mass_update_records(
                "Leads",
                ["123", "456", "789"],
                {"Status": "Qualified", "Rating": "Hot"}
            )

            # Update owner for multiple contacts
            result = await mass_update_records(
                "Contacts",
                ["111", "222", "333"],
                {"Owner": {"id": "4876876000000302001"}},
                trigger_workflow=True
            )
        """
        if len(record_ids) > 100:
            raise ValueError("Maximum 100 records can be updated per call")

        endpoint = f"/{module}"

        # Build records array with same updates for each ID
        records = []
        for record_id in record_ids:
            record_data = {"id": record_id}
            record_data.update(field_updates)
            records.append(record_data)

        # Build request body
        data = {
            "data": records,
            "trigger": ["workflow"] if trigger_workflow else []
        }

        try:
            result = await self.client.put(endpoint, data=data)
            logger.info(f"Mass updated {len(record_ids)} records in {module}")
            return result

        except Exception as e:
            logger.error(f"Error in mass update: {e}")
            raise

    async def format_timeline(self, timeline_data: Dict[str, Any]) -> str:
        """
        Format timeline data into a human-readable string.

        Args:
            timeline_data: Raw timeline data from API

        Returns:
            Formatted timeline string
        """
        if not timeline_data.get("timeline"):
            return "No timeline data available"

        output = []
        output.append("ğŸ“… Record Timeline\n")
        output.append("=" * 60)

        for entry in timeline_data["timeline"]:
            # Header for each entry
            done_by = entry.get("done_by", {}).get("name", "System")
            auditlog_time = entry.get("auditlog_time", "N/A")
            source = entry.get("source", "Unknown")

            output.append(f"\nğŸ• {auditlog_time}")
            output.append(f"ğŸ‘¤ By: {done_by}")
            output.append(f"ğŸ“ Source: {source}")

            # Field changes
            field_history = entry.get("field_history", [])
            if field_history:
                output.append("ğŸ“ Changes:")
                for field in field_history:
                    field_name = field.get("field_label", field.get("api_name", "Unknown"))
                    data_type = field.get("datatype", "")

                    # Format old and new values
                    old_value = field.get("old_value", "N/A")
                    new_value = field.get("new_value", "N/A")

                    output.append(f"   â€¢ {field_name}:")
                    output.append(f"     - Old: {old_value}")
                    output.append(f"     - New: {new_value}")

            output.append("-" * 60)

        # Pagination info
        if timeline_data.get("info", {}).get("more_records"):
            output.append("\nâš ï¸ More records available. Use page_token to fetch next page.")

        return "\n".join(output)
