"""
Zoho CRM Base HTTP Client
Generated by Agent 2 - Base Client Architect

Provides foundation for all Zoho API operations with:
- HTTP request handling
- Error handling and retries
- Rate limiting
- Response parsing
"""

import os
import logging
from typing import Any, Dict, Optional, List
import httpx
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type
)
from dotenv import load_dotenv

from .auth import get_auth
from .utils import clean_zoho_response, format_error_message

load_dotenv()

logger = logging.getLogger(__name__)


class ZohoAPIError(Exception):
    """Base exception for Zoho API errors."""
    pass


class ZohoRateLimitError(ZohoAPIError):
    """Raised when rate limit is exceeded."""
    pass


class ZohoNotFoundError(ZohoAPIError):
    """Raised when resource is not found."""
    pass


class ZohoValidationError(ZohoAPIError):
    """Raised when request validation fails."""
    pass


class ZohoBaseClient:
    """
    Base HTTP client for Zoho CRM API operations.

    Handles:
    - Authentication
    - HTTP requests (GET, POST, PUT, DELETE)
    - Error handling and retries
    - Rate limiting
    - Response parsing

    Usage:
        client = ZohoBaseClient()
        response = await client._request("GET", "/Leads", params={"per_page": 10})
    """

    def __init__(self):
        """Initialize Zoho base client."""
        self.auth = get_auth()
        self.api_domain = os.getenv("ZOHO_API_DOMAIN", "https://www.zohoapis.com")
        self.base_url = f"{self.api_domain}/crm/v8"

        # Configuration
        self.max_retries = int(os.getenv("MAX_RETRIES", "3"))
        self.retry_delay = int(os.getenv("RETRY_DELAY", "2"))
        self.timeout = 30.0

        logger.debug(f"Initialized Zoho client with base URL: {self.base_url}")

    async def _request(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """
        Make an HTTP request to Zoho API with automatic retry and error handling.

        Args:
            method: HTTP method (GET, POST, PUT, DELETE)
            endpoint: API endpoint (e.g., "/Leads" or "/Leads/123")
            params: Query parameters
            json: JSON body for POST/PUT
            headers: Additional headers

        Returns:
            Dict: Parsed JSON response

        Raises:
            ZohoAPIError: On API errors
            ZohoRateLimitError: On rate limit exceeded
            ZohoNotFoundError: On 404
            ZohoValidationError: On validation errors
        """
        # Build full URL
        url = f"{self.base_url}{endpoint}"

        # Get access token
        token = await self.auth.get_access_token()

        # Build headers
        request_headers = {"Authorization": f"Zoho-oauthtoken {token}"}
        if headers:
            request_headers.update(headers)

        # Log request (without sensitive data)
        logger.debug(f"{method} {endpoint} (params: {params})")

        # Make request with retry logic
        try:
            response = await self._make_request_with_retry(
                method=method,
                url=url,
                params=params,
                json=json,
                headers=request_headers
            )

            # Parse and validate response
            return await self._handle_response(response)

        except httpx.HTTPStatusError as e:
            raise await self._handle_http_error(e)
        except httpx.HTTPError as e:
            logger.error(f"HTTP error: {e}")
            raise ZohoAPIError(f"HTTP error: {str(e)}")

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((httpx.TimeoutException, httpx.NetworkError)),
        reraise=True
    )
    async def _make_request_with_retry(
        self,
        method: str,
        url: str,
        params: Optional[Dict] = None,
        json: Optional[Dict] = None,
        headers: Optional[Dict] = None
    ) -> httpx.Response:
        """
        Make HTTP request with automatic retry on transient errors.

        Args:
            method: HTTP method
            url: Full URL
            params: Query parameters
            json: JSON body
            headers: Headers

        Returns:
            httpx.Response: Raw response
        """
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            response = await client.request(
                method=method,
                url=url,
                params=params,
                json=json,
                headers=headers
            )

            # Raise for HTTP errors (will be caught by caller)
            response.raise_for_status()

            return response

    async def _handle_response(self, response: httpx.Response) -> Dict[str, Any]:
        """
        Parse and validate Zoho API response.

        Args:
            response: HTTP response

        Returns:
            Dict: Parsed JSON data

        Raises:
            ZohoAPIError: On API errors
        """
        # Handle empty responses (e.g., DELETE)
        if response.status_code == 204 or not response.content:
            return {"success": True}

        # Parse JSON
        try:
            data = response.json()
        except Exception as e:
            logger.error(f"Failed to parse JSON response: {e}")
            raise ZohoAPIError("Invalid JSON response from Zoho API")

        # Check for API errors in response body
        if isinstance(data, dict):
            # Some errors come with 200 status but have error in body
            if 'code' in data and data['code'] == 'INVALID_TOKEN':
                # Token is invalid, clear cache and retry will refresh
                self.auth._access_token = None
                raise ZohoAPIError("Invalid access token")

            # Check for data-level errors
            if 'data' in data and isinstance(data['data'], list):
                if len(data['data']) > 0:
                    first_item = data['data'][0]
                    if isinstance(first_item, dict) and first_item.get('code') == 'ERROR':
                        error_msg = format_error_message(data)
                        raise ZohoAPIError(error_msg)

        # Clean and return
        return clean_zoho_response(data)

    async def _handle_http_error(self, error: httpx.HTTPStatusError) -> ZohoAPIError:
        """
        Convert HTTP errors to appropriate Zoho exceptions.

        Args:
            error: HTTP status error

        Returns:
            ZohoAPIError: Appropriate exception type
        """
        status_code = error.response.status_code

        # Try to extract error message from response
        try:
            error_data = error.response.json()
            error_msg = format_error_message(error_data)
        except Exception:
            error_msg = f"HTTP {status_code}: {error.response.text}"

        # Map status codes to exceptions
        if status_code == 429:
            logger.warning("Rate limit exceeded, will retry...")
            return ZohoRateLimitError(error_msg)
        elif status_code == 404:
            return ZohoNotFoundError(error_msg)
        elif status_code in (400, 422):
            return ZohoValidationError(error_msg)
        elif status_code == 401:
            # Unauthorized - token might be invalid
            self.auth._access_token = None
            return ZohoAPIError(f"Unauthorized: {error_msg}")
        elif status_code == 403:
            return ZohoAPIError(f"Forbidden: {error_msg}")
        else:
            return ZohoAPIError(error_msg)

    async def get(
        self,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Make a GET request.

        Args:
            endpoint: API endpoint
            params: Query parameters

        Returns:
            Dict: Response data
        """
        return await self._request("GET", endpoint, params=params)

    async def post(
        self,
        endpoint: str,
        data: Dict[str, Any],
        params: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Make a POST request.

        Args:
            endpoint: API endpoint
            data: Request body
            params: Query parameters

        Returns:
            Dict: Response data
        """
        return await self._request("POST", endpoint, json=data, params=params)

    async def put(
        self,
        endpoint: str,
        data: Dict[str, Any],
        params: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Make a PUT request.

        Args:
            endpoint: API endpoint
            data: Request body
            params: Query parameters

        Returns:
            Dict: Response data
        """
        return await self._request("PUT", endpoint, json=data, params=params)

    async def delete(
        self,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Make a DELETE request.

        Args:
            endpoint: API endpoint
            params: Query parameters

        Returns:
            Dict: Response data
        """
        return await self._request("DELETE", endpoint, params=params)

    async def health_check(self) -> bool:
        """
        Check if Zoho API is accessible.

        Returns:
            bool: True if healthy
        """
        try:
            await self.get("/settings/modules")
            return True
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return False
