"""
Zoho CRM Modules API Client
Generated by Agents 3 & 4 - Module Specialists

Handles CRUD operations for all Zoho CRM modules.
"""

import logging
from typing import Any, Dict, List, Optional, AsyncIterator
from .base_client import ZohoBaseClient
from .utils import validate_module_name, extract_record_id
from .pagination import (
    PaginationIterator,
    fetch_all_records,
    build_pagination_params,
    MAX_RECORDS_PER_PAGE
)

logger = logging.getLogger(__name__)


class ZohoModules(ZohoBaseClient):
    """
    Client for Zoho CRM module operations.

    Supports all standard modules:
    - Leads, Contacts, Accounts, Deals
    - Products, Quotes, Sales_Orders, Purchase_Orders, Invoices
    - Vendors

    Usage:
        client = ZohoModules()
        result = await client.create_record("Leads", {"Last_Name": "Smith", "Company": "Acme"})
    """

    async def create_record(
        self,
        module: str,
        data: Dict[str, Any],
        trigger_workflow: bool = True
    ) -> Dict[str, Any]:
        """
        Create a new record in any module.

        Args:
            module: Module name (e.g., "Leads", "Contacts")
            data: Record data
            trigger_workflow: Whether to trigger workflows (default True)

        Returns:
            Dict: Response with record ID

        Example:
            >>> await client.create_record("Leads", {
            ...     "Last_Name": "Doe",
            ...     "Company": "Acme Inc",
            ...     "Email": "john@acme.com"
            ... })
            {"data": [{"code": "SUCCESS", "details": {"id": "123456"}}]}
        """
        payload = {"data": [data]}
        params = {"trigger": ["workflow"]} if trigger_workflow else {}

        response = await self.post(f"/{module}", data=payload, params=params)
        return response

    async def get_record(
        self,
        module: str,
        record_id: str,
        fields: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        Get a single record by ID.

        Args:
            module: Module name
            record_id: Record ID
            fields: List of fields to return (None for all)

        Returns:
            Dict: Record data

        Example:
            >>> await client.get_record("Leads", "123456", fields=["First_Name", "Last_Name", "Email"])
        """
        params = {}
        if fields:
            params["fields"] = ",".join(fields)

        response = await self.get(f"/{module}/{record_id}", params=params)
        return response

    async def get_records(
        self,
        module: str,
        fields: Optional[List[str]] = None,
        page: Optional[int] = 1,
        per_page: int = 200,
        page_token: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_order: str = "desc"
    ) -> Dict[str, Any]:
        """
        Get multiple records from a module with advanced pagination.

        IMPORTANT PAGINATION NOTES:
        - First 2,000 records: Use page/per_page (page number pagination)
        - Beyond 2,000 records: Use page_token (returned in response info.next_page_token)
        - page_token and page are mutually exclusive
        - Maximum 100,000 records total
        - page_token expires after 24 hours

        Args:
            module: Module name
            fields: List of fields to return (None for defaults)
            page: Page number (1-indexed, only for first 2,000 records)
            per_page: Records per page (max 200)
            page_token: Token for pagination beyond 2,000 records
            sort_by: Field to sort by (e.g., "Created_Time")
            sort_order: "asc" or "desc" (default "desc")

        Returns:
            Dict: Response with data and pagination info
                {
                    "data": [...],
                    "info": {
                        "per_page": 200,
                        "count": 200,
                        "page": 1,
                        "more_records": true,
                        "next_page_token": "..."  # Use this for next request
                    }
                }

        Example (first page):
            >>> response = await client.get_records("Leads",
            ...     fields=["First_Name", "Last_Name", "Email"],
            ...     page=1,
            ...     per_page=200
            ... )

        Example (using page_token for records beyond 2,000):
            >>> next_token = response["info"]["next_page_token"]
            >>> response2 = await client.get_records("Leads",
            ...     fields=["First_Name", "Last_Name", "Email"],
            ...     page_token=next_token
            ... )
        """
        # Fields are REQUIRED for get_records in Zoho API
        if not fields:
            # Default important fields for each module
            fields = self._get_default_fields(module)

        # Build base params
        params = {
            "fields": ",".join(fields)
        }

        # Add pagination params (page_token takes precedence)
        pagination_params = build_pagination_params(
            page=None if page_token else page,
            per_page=per_page,
            page_token=page_token
        )
        params.update(pagination_params)

        # Add sorting
        if sort_by:
            params["sort_by"] = sort_by
            params["sort_order"] = sort_order

        response = await self.get(f"/{module}", params=params)
        return response

    async def get_all_records(
        self,
        module: str,
        fields: Optional[List[str]] = None,
        sort_by: Optional[str] = None,
        sort_order: str = "desc",
        max_records: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Fetch ALL records from a module with automatic pagination.

        Automatically handles page_token pagination for datasets > 2,000 records.

        Args:
            module: Module name
            fields: List of fields to return
            sort_by: Field to sort by
            sort_order: "asc" or "desc"
            max_records: Maximum records to fetch (None for all, max 100,000)

        Returns:
            List[Dict]: All records (flattened)

        Example:
            >>> all_leads = await client.get_all_records("Leads",
            ...     fields=["First_Name", "Last_Name", "Email"],
            ...     max_records=5000
            ... )
            >>> print(f"Fetched {len(all_leads)} leads")
        """
        if not fields:
            fields = self._get_default_fields(module)

        base_params = {
            "fields": ",".join(fields)
        }

        if sort_by:
            base_params["sort_by"] = sort_by
            base_params["sort_order"] = sort_order

        return await fetch_all_records(
            client=self,
            endpoint=f"/{module}",
            params=base_params,
            max_records=max_records
        )

    async def iterate_records(
        self,
        module: str,
        fields: Optional[List[str]] = None,
        sort_by: Optional[str] = None,
        sort_order: str = "desc",
        max_records: Optional[int] = None
    ) -> AsyncIterator[List[Dict[str, Any]]]:
        """
        Iterate through records page by page (memory-efficient).

        Yields pages of records instead of loading all into memory.

        Args:
            module: Module name
            fields: List of fields to return
            sort_by: Field to sort by
            sort_order: "asc" or "desc"
            max_records: Maximum total records to fetch

        Yields:
            List[Dict]: Page of records

        Example:
            >>> async for page in client.iterate_records("Leads", max_records=10000):
            ...     print(f"Processing {len(page)} leads...")
            ...     for lead in page:
            ...         process_lead(lead)
        """
        if not fields:
            fields = self._get_default_fields(module)

        base_params = {
            "fields": ",".join(fields)
        }

        if sort_by:
            base_params["sort_by"] = sort_by
            base_params["sort_order"] = sort_order

        async for page_records in PaginationIterator(
            client=self,
            endpoint=f"/{module}",
            base_params=base_params,
            max_records=max_records
        ):
            yield page_records

    async def update_record(
        self,
        module: str,
        record_id: str,
        data: Dict[str, Any],
        trigger_workflow: bool = True
    ) -> Dict[str, Any]:
        """
        Update an existing record.

        Args:
            module: Module name
            record_id: Record ID to update
            data: Fields to update
            trigger_workflow: Whether to trigger workflows

        Returns:
            Dict: Response with update status

        Example:
            >>> await client.update_record("Leads", "123456", {
            ...     "Lead_Status": "Qualified",
            ...     "Email": "newemail@acme.com"
            ... })
        """
        payload = {"data": [data]}
        params = {"trigger": ["workflow"]} if trigger_workflow else {}

        response = await self.put(f"/{module}/{record_id}", data=payload, params=params)
        return response

    async def delete_record(
        self,
        module: str,
        record_id: str,
        trigger_workflow: bool = True
    ) -> Dict[str, Any]:
        """
        Delete a record.

        Args:
            module: Module name
            record_id: Record ID to delete
            trigger_workflow: Whether to trigger workflows

        Returns:
            Dict: Response with deletion status

        Example:
            >>> await client.delete_record("Leads", "123456")
        """
        params = {"wf_trigger": "true" if trigger_workflow else "false"}

        response = await self.delete(f"/{module}/{record_id}", params=params)
        return response

    async def upsert_record(
        self,
        module: str,
        data: Dict[str, Any],
        duplicate_check_fields: Optional[List[str]] = None,
        trigger_workflow: bool = True
    ) -> Dict[str, Any]:
        """
        Create or update a record based on duplicate check fields.

        If a duplicate is found, updates it. Otherwise, creates new record.

        Args:
            module: Module name
            data: Record data
            duplicate_check_fields: Fields to check for duplicates (e.g., ["Email"])
            trigger_workflow: Whether to trigger workflows

        Returns:
            Dict: Response with record ID and action taken

        Example:
            >>> await client.upsert_record("Leads", {
            ...     "Last_Name": "Doe",
            ...     "Email": "john@acme.com"
            ... }, duplicate_check_fields=["Email"])
        """
        payload = {"data": [data]}
        params = {"trigger": ["workflow"]} if trigger_workflow else {}

        if duplicate_check_fields:
            params["duplicate_check_fields"] = ",".join(duplicate_check_fields)

        response = await self.post(f"/{module}/upsert", data=payload, params=params)
        return response

    async def convert_lead(
        self,
        lead_id: str,
        convert_to: Dict[str, bool],
        assign_to: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Convert a Lead to Contact/Account/Deal.

        Args:
            lead_id: Lead ID to convert
            convert_to: What to create {"Contacts": True, "Accounts": True, "Deals": True}
            assign_to: User ID to assign converted records to

        Returns:
            Dict: Response with converted record IDs

        Example:
            >>> await client.convert_lead("123456", {
            ...     "Contacts": True,
            ...     "Accounts": True,
            ...     "Deals": True
            ... })
        """
        payload = {"data": [convert_to]}

        if assign_to:
            payload["data"][0]["assign_to"] = assign_to

        response = await self.post(f"/Leads/{lead_id}/actions/convert", data=payload)
        return response

    def _get_default_fields(self, module: str) -> List[str]:
        """
        Get default fields for a module when none specified.

        Args:
            module: Module name

        Returns:
            List[str]: Default fields for that module
        """
        # Common fields for most modules
        common = ["id", "Created_Time", "Modified_Time", "Owner"]

        # Module-specific important fields
        module_fields = {
            "Leads": ["First_Name", "Last_Name", "Full_Name", "Email", "Phone", "Company", "Lead_Status"],
            "Contacts": ["First_Name", "Last_Name", "Full_Name", "Email", "Phone", "Account_Name"],
            "Accounts": ["Account_Name", "Phone", "Website", "Industry", "Annual_Revenue"],
            "Deals": ["Deal_Name", "Amount", "Stage", "Closing_Date", "Account_Name", "Contact_Name"],
            "Products": ["Product_Name", "Product_Code", "Unit_Price", "Product_Active"],
            "Quotes": ["Subject", "Quote_Stage", "Grand_Total", "Account_Name", "Contact_Name"],
            "Sales_Orders": ["Subject", "Status", "Grand_Total", "Account_Name"],
            "Purchase_Orders": ["Subject", "Status", "Grand_Total", "Vendor_Name"],
            "Invoices": ["Subject", "Status", "Grand_Total", "Account_Name"],
            "Vendors": ["Vendor_Name", "Email", "Phone", "Website"]
        }

        fields = module_fields.get(module, ["id"])
        return common + fields
