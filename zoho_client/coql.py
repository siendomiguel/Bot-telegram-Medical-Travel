"""
Zoho CRM COQL (CRM Object Query Language) Client
Generated by Subagent-2: COQL Query APIs Implementation

Provides SQL-like query capabilities for Zoho CRM:
- Execute COQL queries with SELECT, WHERE, FROM, ORDER BY, LIMIT
- Join operations via lookup fields
- Subqueries for complex filtering
- Aggregate functions (SUM, MAX, MIN, AVG, COUNT)
- Automatic pagination for large result sets
"""

import logging
from typing import Any, Dict, Optional, List
from .base_client import ZohoBaseClient, ZohoAPIError, ZohoValidationError

logger = logging.getLogger(__name__)


class ZohoCOQL(ZohoBaseClient):
    """
    COQL (CRM Object Query Language) client for SQL-like queries in Zoho CRM.

    Features:
    - SQL syntax support (SELECT, WHERE, FROM, ORDER BY, LIMIT, OFFSET, GROUP BY)
    - Join operations via lookup fields
    - Subqueries for complex filtering
    - Cross-module record retrieval
    - Aggregate functions
    - Automatic pagination (max 2000 records per call, 100,000 total)

    Limitations:
    - Maximum 2000 records per query
    - Maximum 100,000 records total (via pagination)
    - Maximum 500 columns in SELECT
    - Maximum 25 criteria in WHERE clause
    - Maximum 10 fields in ORDER BY
    - Maximum 4 fields in GROUP BY

    Usage:
        coql = ZohoCOQL()
        result = await coql.execute_query("SELECT Last_Name, Email FROM Leads WHERE Status = 'Qualified' LIMIT 200")
    """

    async def execute_query(
        self,
        query: str,
        include_meta: bool = False
    ) -> Dict[str, Any]:
        """
        Execute a COQL query and return results.

        Args:
            query: COQL query string (SQL syntax)
                   Example: "SELECT Last_Name, Email FROM Leads WHERE Status = 'Qualified' LIMIT 200"
            include_meta: Include field metadata in response

        Returns:
            Dict with keys:
                - data: List of records
                - info: Query information (count, more_records)
                - meta: Field metadata (if include_meta=True)

        Raises:
            ZohoValidationError: If query syntax is invalid
            ZohoAPIError: On other API errors

        Example:
            >>> result = await coql.execute_query(
            ...     "SELECT id, Full_Name, Email FROM Contacts WHERE Owner.role is not null LIMIT 100"
            ... )
            >>> print(f"Found {result['info']['count']} records")
            >>> for record in result['data']:
            ...     print(record['Full_Name'], record['Email'])
        """
        try:
            # Prepare request body
            request_body = {
                "select_query": query.strip()
            }

            # Add metadata flag if requested
            if include_meta:
                request_body["include_meta"] = ["fields"]

            # Log query (for debugging)
            logger.debug(f"Executing COQL query: {query}")

            # Execute query via POST to /coql endpoint
            response = await self.post("/coql", data=request_body)

            # Log result summary
            if 'info' in response:
                count = response['info'].get('count', 0)
                more_records = response['info'].get('more_records', False)
                logger.debug(f"Query returned {count} records (more_records: {more_records})")

            return response

        except ZohoValidationError as e:
            # Re-raise validation errors with context
            raise ZohoValidationError(f"Invalid COQL query: {str(e)}")
        except Exception as e:
            logger.error(f"Failed to execute COQL query: {e}")
            raise

    async def execute_with_pagination(
        self,
        query: str,
        max_records: int = 2000
    ) -> Dict[str, Any]:
        """
        Execute COQL query with automatic pagination.

        Handles pagination automatically by adjusting LIMIT and OFFSET clauses.
        Maximum 100,000 records can be retrieved across all pages.

        Args:
            query: Base COQL query (without LIMIT/OFFSET or with initial values)
            max_records: Maximum total records to retrieve (default: 2000, max: 100000)

        Returns:
            Dict with keys:
                - data: Combined list of all records from all pages
                - info: Summary information
                    - total_count: Total records retrieved
                    - pages_fetched: Number of API calls made
                    - truncated: True if max_records limit was reached

        Raises:
            ZohoValidationError: If query syntax is invalid
            ZohoAPIError: On other API errors

        Example:
            >>> # Fetch up to 5000 leads
            >>> result = await coql.execute_with_pagination(
            ...     "SELECT Last_Name, Email, Company FROM Leads WHERE Status = 'Qualified'",
            ...     max_records=5000
            ... )
            >>> print(f"Retrieved {result['info']['total_count']} leads across {result['info']['pages_fetched']} pages")
        """
        # Validate max_records
        if max_records > 100000:
            logger.warning(f"max_records {max_records} exceeds COQL limit of 100,000. Setting to 100,000.")
            max_records = 100000

        all_records = []
        offset = 0
        page_size = min(2000, max_records)  # COQL max per request is 2000
        pages_fetched = 0
        truncated = False

        # Remove existing LIMIT/OFFSET from query if present
        query_base = self._remove_limit_offset(query)

        while len(all_records) < max_records:
            # Calculate records to fetch in this iteration
            remaining = max_records - len(all_records)
            current_limit = min(page_size, remaining)

            # Build paginated query
            paginated_query = f"{query_base} LIMIT {offset}, {current_limit}"

            try:
                # Execute query
                result = await self.execute_query(paginated_query)

                # Extract records
                records = result.get('data', [])
                if not records:
                    break

                all_records.extend(records)
                pages_fetched += 1

                # Check if more records available
                more_records = result.get('info', {}).get('more_records', False)
                if not more_records:
                    break

                # Move to next page
                offset += current_limit

                # Safety check for infinite loops
                if pages_fetched >= 50:  # 50 pages * 2000 = 100,000 max
                    logger.warning("Reached maximum pagination limit (50 pages)")
                    truncated = True
                    break

            except Exception as e:
                logger.error(f"Pagination failed at offset {offset}: {e}")
                # Return partial results if we got some data
                if all_records:
                    truncated = True
                    break
                else:
                    raise

        return {
            "data": all_records,
            "info": {
                "total_count": len(all_records),
                "pages_fetched": pages_fetched,
                "truncated": truncated
            }
        }

    async def validate_query(self, query: str) -> Dict[str, Any]:
        """
        Validate COQL query syntax without executing it.

        Performs basic syntax validation and checks for common errors.
        Note: This does NOT validate against actual CRM schema (field names, modules, etc.)
        For full validation, use execute_query with a LIMIT 0 clause.

        Args:
            query: COQL query to validate

        Returns:
            Dict with keys:
                - valid: Boolean indicating if query is valid
                - errors: List of error messages (if invalid)
                - warnings: List of warnings

        Example:
            >>> validation = await coql.validate_query("SELECT FROM Leads")
            >>> if not validation['valid']:
            ...     print("Errors:", validation['errors'])
        """
        errors = []
        warnings = []

        query = query.strip()
        query_upper = query.upper()

        # Check for required SELECT clause
        if not query_upper.startswith("SELECT"):
            errors.append("Query must start with SELECT")

        # Check for FROM clause
        if " FROM " not in query_upper:
            errors.append("Query must contain FROM clause")

        # Check for empty SELECT
        if query_upper.startswith("SELECT FROM"):
            errors.append("SELECT clause cannot be empty (must specify fields or *)")

        # Check for common syntax issues
        if query.count("(") != query.count(")"):
            errors.append("Unbalanced parentheses in query")

        # Check for unsupported features
        if " JOIN " in query_upper and " ON " in query_upper:
            warnings.append("Explicit JOIN syntax not supported. Use dot notation for joins (e.g., Account_Name.Parent_Account)")

        # Check field/criteria limits
        if query_upper.count(" WHERE ") > 0:
            # Rough estimate of criteria count (actual parsing would be complex)
            where_clause = query_upper.split(" WHERE ")[1].split(" ORDER BY ")[0] if " ORDER BY " in query_upper else query_upper.split(" WHERE ")[1]
            and_count = where_clause.count(" AND ")
            or_count = where_clause.count(" OR ")
            if and_count + or_count > 25:
                warnings.append(f"Query may exceed maximum 25 criteria in WHERE clause ({and_count + or_count} operators found)")

        # Check ORDER BY field limit
        if " ORDER BY " in query_upper:
            order_by_clause = query.split(" ORDER BY ")[1].split(" LIMIT ")[0] if " LIMIT " in query else query.split(" ORDER BY ")[1]
            order_by_fields = order_by_clause.count(",") + 1
            if order_by_fields > 10:
                warnings.append(f"Query may exceed maximum 10 fields in ORDER BY ({order_by_fields} found)")

        # Check GROUP BY field limit
        if " GROUP BY " in query_upper:
            group_by_clause = query.split(" GROUP BY ")[1].split(" ORDER BY ")[0] if " ORDER BY " in query else query.split(" GROUP BY ")[1]
            group_by_fields = group_by_clause.count(",") + 1
            if group_by_fields > 4:
                warnings.append(f"Query may exceed maximum 4 fields in GROUP BY ({group_by_fields} found)")

        # Check for LIMIT
        if " LIMIT " not in query_upper:
            warnings.append("No LIMIT clause specified. Consider adding LIMIT to avoid large result sets.")
        else:
            # Extract LIMIT value
            try:
                limit_part = query.split(" LIMIT ")[1].split()[0].replace(",", " ").split()[0]
                if "," in query.split(" LIMIT ")[1].split()[0]:
                    # LIMIT offset, count format
                    limit_value = int(query.split(" LIMIT ")[1].split()[0].split(",")[1].strip())
                else:
                    limit_value = int(limit_part)

                if limit_value > 2000:
                    errors.append(f"LIMIT {limit_value} exceeds maximum of 2000 records per query")
            except (ValueError, IndexError):
                warnings.append("Could not parse LIMIT value")

        # Determine if valid
        is_valid = len(errors) == 0

        result = {
            "valid": is_valid,
            "errors": errors,
            "warnings": warnings
        }

        if is_valid:
            logger.debug(f"Query validation passed with {len(warnings)} warnings")
        else:
            logger.warning(f"Query validation failed with {len(errors)} errors")

        return result

    def _remove_limit_offset(self, query: str) -> str:
        """
        Remove LIMIT and OFFSET clauses from query.

        Args:
            query: COQL query

        Returns:
            Query without LIMIT/OFFSET
        """
        query_upper = query.upper()

        # Find LIMIT position
        if " LIMIT " in query_upper:
            limit_pos = query_upper.index(" LIMIT ")
            # Keep everything before LIMIT
            return query[:limit_pos].strip()

        return query.strip()

    async def build_query_from_conditions(
        self,
        module: str,
        fields: Optional[List[str]] = None,
        conditions: Optional[Dict[str, Any]] = None,
        order_by: Optional[str] = None,
        limit: int = 200
    ) -> str:
        """
        Build a COQL query from structured parameters.

        Convenience method to construct COQL queries programmatically.

        Args:
            module: Module API name (e.g., "Leads", "Contacts")
            fields: List of field API names to select (None = all fields using *)
            conditions: Dict of field-value pairs for WHERE clause
                       Example: {"Status": "Qualified", "Rating": "Hot"}
            order_by: Field name to order by (prefix with "-" for DESC)
                     Example: "Created_Time" or "-Modified_Time"
            limit: Maximum records to return (default: 200, max: 2000)

        Returns:
            COQL query string

        Example:
            >>> query = await coql.build_query_from_conditions(
            ...     module="Leads",
            ...     fields=["Last_Name", "Email", "Company"],
            ...     conditions={"Status": "Qualified", "Rating": "Hot"},
            ...     order_by="-Created_Time",
            ...     limit=100
            ... )
            >>> print(query)
            SELECT Last_Name, Email, Company FROM Leads WHERE Status = 'Qualified' AND Rating = 'Hot' ORDER BY Created_Time DESC LIMIT 100
        """
        # Build SELECT clause
        if fields and len(fields) > 0:
            select_clause = ", ".join(fields)
        else:
            select_clause = "*"

        # Build FROM clause
        from_clause = module

        # Build WHERE clause
        where_clause = ""
        if conditions and len(conditions) > 0:
            where_parts = []
            for field, value in conditions.items():
                if value is None:
                    where_parts.append(f"{field} is null")
                elif isinstance(value, bool):
                    where_parts.append(f"{field} = {str(value).lower()}")
                elif isinstance(value, (int, float)):
                    where_parts.append(f"{field} = {value}")
                elif isinstance(value, str):
                    # Escape single quotes in string values
                    escaped_value = value.replace("'", "\\'")
                    where_parts.append(f"{field} = '{escaped_value}'")
                elif isinstance(value, list):
                    # Handle IN operator
                    if all(isinstance(v, str) for v in value):
                        values_str = ", ".join([f"'{v}'" for v in value])
                    else:
                        values_str = ", ".join([str(v) for v in value])
                    where_parts.append(f"{field} in ({values_str})")

            if where_parts:
                where_clause = " WHERE " + " AND ".join(where_parts)

        # Build ORDER BY clause
        order_clause = ""
        if order_by:
            if order_by.startswith("-"):
                order_clause = f" ORDER BY {order_by[1:]} DESC"
            else:
                order_clause = f" ORDER BY {order_by} ASC"

        # Build LIMIT clause
        limit_value = min(limit, 2000)  # Cap at COQL max
        limit_clause = f" LIMIT {limit_value}"

        # Combine all parts
        query = f"SELECT {select_clause} FROM {from_clause}{where_clause}{order_clause}{limit_clause}"

        logger.debug(f"Built query: {query}")

        return query
